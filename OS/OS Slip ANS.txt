SLip 1

/* ASSIGNMENT 1 SET B 
Q.1. Write a program that demonstrates the use of nice() system call. After a child process is started using fork(), assign higher priority to the child using nice() system call.*/

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
void main()
{
int pid, retnice;
printf("press DEL to stop process \n");
pid=fork();
    for(;;)
    {
        if(pid == 0)
            {
            retnice = nice(-5);
            printf("child gets higher CPU priority %d \n", retnice);
            sleep(1);
            }
        else
            {
            retnice=nice(4);
            printf("Parent gets lower CPU priority %d \n", retnice);
            sleep(1);
            }
    }
}


Q2.

//Bankers algorithm
#include<stdio.h>
int main()
{
  // p0,p1,p2,p3,p4 are the process names here
int n,m,i,j,l,k,a,b;
n=5;//Number of process
m=3;// Number of resources
int need[n][m];
//allocation matrix
int alloc[5][3]={{0,1,0},//p0
  {2,0,0},
   {3,0,2},
   {2,1,1},
   {0,0,2}};

// max matrix
int max[5][3] = {{7,5,3},
  
   {3,2,2},
   {9,0,2},
   {2,2,2},
   {4,3,3}};
printf("Allocation\t   Max\t\tNeed(Max-Allocation)");
printf("\n");
 for(a=0;a<n;a++)
{
   for(b=0;b<m;b++)
      printf("%d ",alloc[a][b]);
    printf("\t\t");
   for(b=0;b<m;b++)
      printf("%d ",max[a][b]);
    printf("\t\t");
   for(b=0;b<m;b++)
    {
      need[a][b] = max [a][b]-alloc[a][b];
      printf("%d ",need[a][b]);
    }
  printf("\n");
}  
   

int avail[3]=  {3,3,2};//available resources
 int f[n],ans[n],ind=0;
for(k=0;k<n;k++)
{
  f[k]=0;
}
printf("\nAvail matrix\n");
int y=0;
for(k=0;k<5;k++)
{
  for(i=0;i<n;i++)
{
   if(f[i]==0)
{
  int flag=0;
  for(j=0;j<m;j++)
{
  if (need[i][j]>avail[j])
{
    flag=1;
    break;
}
}
if(flag==0)
{
  ans[ind++]=i;
  for(y=0;y<m;y++)
  avail[y]+=alloc[i][y];
  f[i]=1;
}
}
}
}
for(i=0;i<m;i++)
  printf("%d  ",avail[i]);
printf("\n\nFollowing is the safe sequence\n");
for(i=0;i<n-1;i++)
  printf("p%d->",ans[i]);
printf("p%d",ans[n-1]);
return (0);
}
 


Slip 2

/*Assignment 1 Set A 
1.Create a child process using fork(), display parent and child 
process id. Child process will display the message “Hello World” and 
the parent process should display “Hi”. 
*/
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
void forkexample()
{
	// child process because return value zero
	if (fork() == 0)
	{
		printf("Hello World from Child!\n");
		printf("Child Process Id is : %d", getpid());
	}
	// parent process because return value non-zero.
	else if (fork() >0 )
	{
		printf("Hi from Parent!\n");
		printf("parent Process ID is %d",getpid())
	}		
}
int main()
{
	forkexample();
	return 0;
}


Q2

/*
Write the simulation program using SJF(NON preemptive).
The arrival time and first CPU bursts of different jobs should be
input to the system.The Assume the fixed I/O waiting time (2 units).
The next CPU burst should be generated using random function.
The output should give the Gantt chart,
Turnaround Time and Waiting time for each process and average times
*/
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int AT[20]={1,3,6,7,9},BT[20]={7,3,2,10,8};
char ch ='-';
int CT[20],TT[20],p[20]={1,2,3,4,5},wt[20],tat[20],temp_BT[20];
int flag[20], first_time=1,finish = 0, shortest_job_pos;
int i,j,x,n=5,pos,temp,cmpl_T;
float Total_TT=0,Total_WT=0;
void SJF(int bt[])
{
    int min_pos,k;
    if(first_time == 1)
    {
       shortest_job_pos = find_min(AT);
       x=cmpl_T=AT[shortest_job_pos];
       printf("======SJF Non Preemptive====\n");
       printf("\n Gantt Chart    \n");
       printf(" ");
       for(i=0;i<= (n-1)*8;i++)
	printf("%c",ch);

       printf("\n");

       for(i=0;i<n+1;i++)
	  printf("|      ");

       printf("\n");
       printf("|" );
     }
    for(i=0;i<n;i++)
    {
      if( first_time ==1 && flag[shortest_job_pos] == 0)// first job
       {
		cmpl_T += BT[shortest_job_pos];
		CT[shortest_job_pos]=cmpl_T;
		TT[shortest_job_pos]=cmpl_T-AT[shortest_job_pos];
		Total_TT+=TT[i];
		//printf("%d\t",cmpl_T);
		flag[shortest_job_pos]= 1;
		first_time=0;
       }
       else //if(first_time == 0),now it is not first job,find the shortest job
       {
	  for ( i= 0;i<=n; i++)
	  {
	   if( AT[i] <= cmpl_T && flag[i]==0)
	       temp_BT[i]= BT[i];
	  }
	    for( i=0;i<=cmpl_T ; i++)
	    {
		shortest_job_pos = find_min_BT(temp_BT);
		cmpl_T += temp_BT[shortest_job_pos];
		CT[shortest_job_pos]=cmpl_T;
		TT[shortest_job_pos]=cmpl_T-AT[shortest_job_pos];
		wt[shortest_job_pos]=TT[shortest_job_pos]-temp_BT[shortest_job_pos];
		Total_TT+=TT[shortest_job_pos];
		break;
	   }      // end of for
	 }// end of else if
	 for(k=0;k<n;k++)
	    temp_BT[k]=0;
	 printf("  P%d  |",p[shortest_job_pos]);
	 finish++;
	 if (finish == n)
	    return;
       } //end of for
//}//end of while
return k;
}
//---------------------------------------------------------
sort_CT()
{
int i,j,temp;
for(i=0;i<n;i++)
    {
	for(j=i+1;j<n;j++)
	{
	    if(CT[j] < CT[i])
	     {
		temp=CT[i];
		CT[i]=CT[j];
		CT[j]=temp;
	     }
	}
}
}
//----------------------------------------------------------------
int find_min(int a[])
 {
    int i, minimum, minimum_pos;
    minimum= a[0];
    //first_time = 1;
    for ( i=0 ;i<n ; i++)
    {
     if (a[i] < minimum  && flag[i] != 1)
	{
	minimum = a[i];
	minimum_pos= i;
	}
    }
    return minimum_pos;
}
//-----------------------------------------------------------------
int find_min_BT(int a[])
 {
    int i,j,minimum, minimum_pos;
    for(i=0;i<n ;i++)
     if ( a[i] !=0)
     {
	  minimum= a[i];
	  break;
     }
    for ( j=i+1;j<n; j++)
     if (a[j] < minimum  && flag[j] != 1)
	minimum = a[j];
    flag[i]= 1;
    return i;
}
//----------------------------------------------------------------------
 int main()
{
    int k,min,pos,p_id,CT_1[20];
    float avg_wt,avg_tat;
    time_t t;

    clrscr();
    for(i=0;i<n;i++)
    flag[i] = 0;
    /*printf("Enter number of process:");
    scanf("%d",&n);
      */
 /* printf("Enter Arrival time of the processess\n");
    printf("AT\n");
    for(i=0;i<n;i++)
    {
	scanf("%d",&AT[i]);
    }*/
//    printf("Enter the Burst time of first process\n");
  //  scanf("%d",&BT[0]);

  /*printf("Enter the Burst time of the process\n");
   for(i=0;i<n;i++)
    {
	scanf("%d",&BT[i]);
    }*/
   /* Intializes random number generator */
    // srand((unsigned) time(&t));

   /* For Burst time generate n random numbers from 0 to 10 */
  /*  for( i = 1 ; i < n ; i++ )
	 BT[i]= rand() % 10;
    printf("Burst Times generated using random funtion are...\n");
    for (i=0;i<n;i++)
       printf("%d\n",BT[i]);
    */

   //sorting of burst times
    for(i=0;i<n;i++)
    {
	pos=i;
	for(j=i+1;j<n;j++)
	{
	    if(BT[j]<BT[pos])
		pos=j;
	}

	temp=BT[i];
	BT[i]=BT[pos];
	BT[pos]=temp;

	temp=p[i];
	p[i]=p[pos];
	p[pos]=temp;

	temp=AT[i];
	AT[i]=AT[pos];
	AT[pos]=temp;

    }

    cmpl_T=0;
    SJF(BT);
    printf("\n");
    printf(" ");
    for(i=0;i<= (n-1)*8;i++)
    {
	   printf("%c",ch);
    }
    printf("\n%d   ",x);
    for(i=0;i<n;i++)
      CT_1[i]= CT[i];
    sort_CT();
    for (i=0;i<n;i++)
    {
	  printf("   %d  ",CT[i]);
    }
    printf("\n\n\nProcess\tArrival Time\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time\t\n");
    for(i=0;i<n;i++)
    {
	printf(" P%d\t  %d\t\t%d\t\t    %d\t\t  %d\t\t%d\n",i+1,AT[i],BT[i],CT_1[i],TT[i],wt[i]);
    }
    for(i=0;i<n;i++)
       Total_WT+= wt[i];
    avg_wt=(float)Total_WT/n;
    printf("\nAverage Waiting Time=%.1f",avg_wt);

    for(i=0;i<n;i++)
       Total_TT+= TT[i];
    avg_tat=(float)Total_TT/n;
    printf("\nAverage Turnaround Time=%.1f",avg_tat);
    getch();
}


Slip 3

Q1 #include<stdio.h>
#include<unistd.h>

int main()
{
	int i;
	
	printf("I am EXEC.c called by execvp() ");
	printf("\n");
	
	return 0;
}
//Now,create an executable file of EXEC.c using command

// gcc EXEC.c -o EXEC

//execDemo.c

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
int main()
{
		//A null terminated array of character pointers
		char *args[]={"./EXEC",NULL};
		execvp(args[0],args);
	
printf("Ending-----");
	
	return 0;
}


Q2 5.	#include <stdio.h>
6.	int main()
7.	{
8.	    int pid[15];
9.	    int bt[15];
10.	    int n;
11.	    printf("Enter the number of processes: ");
12.	    scanf("%d",&n);
13.	 
14.	    printf("Enter process id of all the processes: ");
15.	    for(int i=0;i<n;i++)
16.	    {
17.	        scanf("%d",&pid[i]);
18.	    }
19.	 
20.	    printf("Enter burst time of all the processes: ");
21.	    for(int i=0;i<n;i++)
22.	    {
23.	        scanf("%d",&bt[i]);
24.	    }
25.	 
26.	    int i, wt[n];
27.	    wt[0]=0;
28.	 
29.	    //for calculating waiting time of each process
30.	    for(i=1; i<n; i++)
31.	    {
32.	        wt[i]= bt[i-1]+ wt[i-1];
33.	    }
34.	 
35.	    printf("Process ID     Burst Time     Waiting Time     TurnAround Time\n");
36.	    float twt=0.0;
37.	    float tat= 0.0;
38.	    for(i=0; i<n; i++)
39.	    {
40.	        printf("%d\t\t", pid[i]);
41.	        printf("%d\t\t", bt[i]);
42.	        printf("%d\t\t", wt[i]);
43.	 
44.	        //calculating and printing turnaround time of each process
45.	        printf("%d\t\t", bt[i]+wt[i]);
46.	        printf("\n");
47.	 
48.	        //for calculating total waiting time
49.	        twt += wt[i];
50.	 
51.	        //for calculating total turnaround time
52.	        tat += (wt[i]+bt[i]);
53.	    }
54.	    float att,awt;
55.	 
56.	    //for calculating average waiting time
57.	    awt = twt/n;
58.	 
59.	    //for calculating average turnaround time
60.	    att = tat/n;
61.	    printf("Avg. waiting time= %f\n",awt);
62.	    printf("Avg. turnaround time= %f",att);
63.	}


Slip 4
 
Q1  /*ASSIGNMENT 1 Set B
Q.1. Write a program to illustrate the concept of orphan process ( Using fork() and
sleep())( Refer Program 5).*/
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
int main()
{
   int pid=fork();
   if(pid>0)
 {
     printf("in parent process\n");
     printf("PID: %d\n",getpid());
  }
   else if(pid==0)
  {
    sleep(10);
    printf("\nin child process");
    printf("\nPID: %d",getppid());
    printf("\nChild PID:%d",getpid());
  }
    return 0;
 }
//Note that pid is 0 in child process and negative if
//fork()fails


Q2 

/* ASSIGNMENT 2 SET B
Q.2 Write the program to simulate Non-preemptive Priority scheduling.
The arrival time andfirst CPU-burst and priority for different n
number of processes should be input to thealgorithm.
Assume the fixed IO waiting time (2 units).
The next CPU-burst should be generated randomly.
The output should give Gantt chart, turnaround time and waiting
time for each process. Also find the average waiting time and turnaround time.
*/
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
    int at[20],pr[20],bt[20];
    int p[20],wt[20],CT[20], TT[20],RT[20],i,j,n;
    int Total_wt=0,Total_TT=0,pos,temp,cmpl_T;
    float avg_wt,avg_tat;
    time_t t;
    char ch ='-';

void main()
{
    printf("Enter Total Number of Process:");
    scanf("%d",&n);
    for(i=0; i< n; i++)
      p[i]=i+1;

    printf("Enter Arrival time of the processess\n");
    printf("AT\n");
    for(i=0;i<n;i++)
    {
	scanf("%d",&at[i]);
    }
    printf("Enter Burst time of the processess\n");
    printf("BT\n");
    for(i=0;i<n;i++)
    {
	scanf("%d",&bt[i]);
    }

    printf("Enter Priority of the processess\n");
    for(i=0;i<n;i++)
    {
	scanf("%d",&pr[i]);
    }

    //sorting burst time, priority and process number in ascending order using selection sort
    for(i=0;i<n;i++)
    {
	pos=i;
	for(j=i+1;j<n;j++)
	{
	    if(pr[j]<pr[pos])
		pos=j;
	}
	temp=at[i];
	at[i]=at[pos];
	at[pos]=temp;

	temp=pr[i];
	pr[i]=pr[pos];
	pr[pos]=temp;

	temp=bt[i];
	bt[i]=bt[pos];
	bt[pos]=temp;

	temp=p[i];
	p[i]=p[pos];
	p[pos]=temp;
    }

    wt[0]=0; //waiting time for first process is zero
    cmpl_T=0;
    Total_wt=0;
    Total_TT=0;

   // Printing Gantt Chart
    printf("\n        =======Non Preemptive Priority Scheduling========\n");
    printf("\n Gantt Chart    \n");
       printf(" ");
       for(i=0;i<= n*8;i++)
	   printf("%c",ch);

       printf("\n");
       printf("|");

       for(i=0;i<n;i++)
	printf("  P%d   |",p[i]);
       printf("\n");
        printf("|" );
    for(i=0;i<n;i++)
    {
	cmpl_T+=bt[i];
	CT[i]=cmpl_T;
	TT[i]=CT[i]-at[i];
	wt[i]= TT[i] - bt[i];
	RT[i]= wt[i] + at[i];
	Total_wt+=wt[i];
	Total_TT+=TT[i];
	printf("%d\t",cmpl_T);
     }
    printf(" ");
    for(i=0;i<n*8;i++)
    {
	   printf("%c",ch);
    }
    printf("\n0");
    for(i=0;i<n;i++)
      printf("%8d",CT[i]);

    printf("\n\nPID  Priority    AT\t  BT\t  CT\t  TT\t  WT\t  RT\n");
    printf("-------------------------------------------------------------");
    for(i=0;i<n;i++)
    {
	printf("\nP%d\t  %d\t  %d\t  %d\t  %d\t  %d\t  %d\t  %d",p[i],pr[i],at[i],bt[i],CT[i],TT[i],wt[i],RT[i]);
    }

    avg_wt=Total_wt/n; //average waiting time
    avg_tat=Total_TT/n;//average turnaround time
    printf("\n\nAverage Waiting Time=%.1f",avg_wt);
    printf("\nAverage Turnaround Time=%.1f\n",avg_tat);
   
}

Slip 5

/* ASSIGNMENT 1 SET B 
Q.2. Write a program that demonstrates the use of nice() system call. After a child process is started using fork(), assign higher priority to the child using nice() system call.*/

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
void main()
{
int pid, retnice;
printf("press DEL to stop process \n");
pid=fork();
    for(;;)
    {
        if(pid == 0)
            {
            retnice = nice(-5);
            printf("child gets higher CPU priority %d \n", retnice);
            sleep(1);
            }
        else
            {
            retnice=nice(4);
            printf("Parent gets lower CPU priority %d \n", retnice);
            sleep(1);
            }
    }
}

Q2

/* ASSIGNMENT 4 Set A
Q.2. Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String :3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6
i. Implement FIFO*/
#include<stdio.h>
int n=15,nf;//n is length of reference string
int in[20]={3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6};//Reference String
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;

void getData()
{
	printf("\nEnter no of frames:");
	scanf("%d",&nf);
}

void initialize()
{
	pgfaultcnt=0;
	for(i=0; i<nf; i++)
		p[i]=9999;
}

int isHit(int data)
{
	hit=0;
	for(j=0; j<nf; j++)
	{
		if(p[j]==data)
		{
			hit=1;
			break;
		}
	}
	return hit;
}

int getHitIndex(int data)
{
	int hitind;
	for(k=0; k<nf; k++)
	{
		if(p[k]==data)
		{
			hitind=k;
			break;
		}
	}
	return hitind;
}

void dispPages()
{
	for (k=0; k<nf; k++)
	{
		if(p[k]!=9999)
			printf(" %d",p[k]);
	}
}

void dispPgFaultCnt()
{
	printf("\nTotal no of page faults:%d",pgfaultcnt);
}

void fifo()
{
	initialize();
	for(i=0; i<n; i++)
	{
		printf("\nFor %d :",in[i]);
		
		if(isHit(in[i])==0)
		{
			for(k=0; k<nf-1; k++)
			p[k]=p[k+1];

		p[k]=in[i];
		pgfaultcnt++;
		dispPages();
	}
	else
		printf("No page fault");
	}
	dispPgFaultCnt();
}


int main()
{
        getData();
        fifo();
}
 



SLip 6

/*ASSIGNMENT 1 SET B Q.3
Write a program to find the execution time taken for execution of a given set of instructions (use clock() function)*/


#include <time.h>
#include <stdio.h>

int main () {
   clock_t start_t, end_t, total_t;
   int i;

   start_t = clock();
   printf("Starting of the program, start_t = %ld\n", start_t);
    
   printf("Going to scan a big loop, start_t = %ld\n", start_t);
   for(i=0; i< 10000000; i++) {
   }
   end_t = clock();
   printf("End of the big loop, end_t = %ld\n", end_t);
   
   total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;
   printf("Total time taken by CPU: %f\n", total_t  );
   printf("Exiting of the program...\n");

   return(0);
}

Q2

/* ASSIGNMENT 4 Set A
Q.2. Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String :3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6
i. Implement FIFO*/
#include<stdio.h>
int n=15,nf;//n is length of reference string
int in[20]={3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6};//Reference String
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;

void getData()
{
	printf("\nEnter no of frames:");
	scanf("%d",&nf);
}

void initialize()
{
	pgfaultcnt=0;
	for(i=0; i<nf; i++)
		p[i]=9999;
}

int isHit(int data)
{
	hit=0;
	for(j=0; j<nf; j++)
	{
		if(p[j]==data)
		{
			hit=1;
			break;
		}
	}
	return hit;
}

int getHitIndex(int data)
{
	int hitind;
	for(k=0; k<nf; k++)
	{
		if(p[k]==data)
		{
			hitind=k;
			break;
		}
	}
	return hitind;
}

void dispPages()
{
	for (k=0; k<nf; k++)
	{
		if(p[k]!=9999)
			printf(" %d",p[k]);
	}
}

void dispPgFaultCnt()
{
	printf("\nTotal no of page faults:%d",pgfaultcnt);
}

void fifo()
{
	initialize();
	for(i=0; i<n; i++)
	{
		printf("\nFor %d :",in[i]);
		
		if(isHit(in[i])==0)
		{
			for(k=0; k<nf-1; k++)
			p[k]=p[k+1];

		p[k]=in[i];
		pgfaultcnt++;
		dispPages();
	}
	else
		printf("No page fault");
	}
	dispPgFaultCnt();
}


int main()
{
        getData();
        fifo();
}
 



SLip 7

/*ASSIGNMENT 1 SET A 
3. Creating a child process without terminating the parent process Write a program to create a child process using fork().The parent should goto sleep state and child process should begin its execution. In the child process, use execl() to execute the “ls” command.*/

#include <unistd.h>
#include<stdio.h> 
int main(void) 
{
	int f;
	char *binaryPath = "/bin/ls";
  	char *arg1 = "-lh";
  	char *arg2 = "/home";
    	printf("Creating a child process with fork...\n");
	fork();
	sleep(5);
	printf("Parent process is Sleeping for 5 seconds \n");
	execl(binaryPath, binaryPath, arg1, arg2, NULL);
	printf("Sleep is now over \n");
 	return 0;
}


Q2

/*ASSIGNMENT 4 SET B Q.2
Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String :7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
i. Implement LRU*/

#include<stdio.h>
int n=14,nf;
int in[20]={7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
 
    }
 
    return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 
}
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
void lru()
{
    initialize();
 
    int least[50];
    for(i=0; i<n; i++)
    {
 
        printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
 
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i-1; k>=0; k--)
                {
                    if(pg==in[k])
                    {
                        least[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    least[j]=-9999;
            }
            int min=9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(least[j]<min)
                {
                    min=least[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault!");
    }
    dispPgFaultCnt();
}
 
void main()
{
            getData();
            lru();
}

Slip 8

/*Q2)2. Write a C program to accept the number of process and resources and find the need matrix content and display it. */

#include<stdio.h>
#include<stdlib.h>
int main()
{
int n,m,i,j,k,a,b;
int alloc[10][10],max[10][10],need[10][10],avail[10][10];
int work[10];  //available resources
int total_resources[10],temp[10];

printf("Enter no of processes: ");
scanf("%d",&n);

printf("Enter no of resources: ");
scanf("%d",&m);

for(i=0;i<m;i++)
{
   printf("Enter no. of instances of resource %d: \n",i+1);
   scanf("%d",&total_resources[i]);
}

printf("Enter allocation matrix\n");
for (i=0;i<n;i++) {
  for (j=0;j<m;j++) {
 	scanf("%d",&alloc[i][j]);
   }
}

printf("Enter MAX matrix\n");
for (i=0;i<n;i++) {
   for (j=0;j<m;j++) {
 	scanf("%d",&max[i][j]);
   }
}
printf("Enter Avail matrix\n");
for (i=0;i<n;i++) {
   for (j=0;j<m;j++) {
 	scanf("%d",&avail[i][j]);
}
}



printf("Allocation Matrix is .....\n");
for (i=0;i<n;i++)
{
   for (j=0;j<m;j++)
 	printf("%d  ",alloc[i][j]);
    printf("\n");
}

printf("Max Matrix is .....\n");
for (i=0;i<n;i++)
{
   for (j=0;j<m;j++)
 	printf("%d  ",max[i][j]);
    printf("\n");
}
for(i=0;i<n;i++)
{
	  for(j=0;j<m;j++)
	  {
		need[i][j]=max[i][j]-alloc[i][j];
	  }
	  printf("\n");
}
printf("Need Matrix is ....\n");
	for(i=0;i<n;i++)
	{
	  for(j=0;j<m;j++)
	  {
		printf("%d\t",need[i][j] );
	  }
	  printf("\n");
	}
}


Q2 

/*ASSIGNMENT-4-SET-B-Q.1
 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
i. Implement OPT

*/#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}

Slip 9

/*ASSIGNMENT 1 SET A 
3. Creating a child process without terminating the parent process Write a program to create a child process using fork().The parent should goto sleep state and child process should begin its execution. In the child process, use execl() to execute the “ls” command.*/

#include <unistd.h>
#include<stdio.h> 
int main(void) 
{
	int f;
	char *binaryPath = "/bin/ls";
  	char *arg1 = "-lh";
  	char *arg2 = "/home";
    	printf("Creating a child process with fork...\n");
	fork();
	sleep(5);
	printf("Parent process is Sleeping for 5 seconds \n");
	execl(binaryPath, binaryPath, arg1, arg2, NULL);
	printf("Sleep is now over \n");
 	return 0;
}


Q2

//ASSIGNMENT 3 SET B Q.1
/*Partially implement the Menu driven Banker's algorithm for accepting Allocation, Max from user.
a) Accept Available
b) Display Allocation, Max
c) Find Need and display It,
d) Display Available
*/
 #include<stdio.h>
 #include<stdlib.h>
  int n, m, i, j, l, k, a, b;
  // n is Number of process
  //m is Number of resources
  int need[10][10];
  int alloc[10][10];
  int max[10][10],avail[10];
  int choice;
   void get_data();
   void display_alloc_need();
   void display_avail();

void main ()
{
 
  while(1)
  {
   printf("\n********MENU*********\n");
   printf("1. Accept ALLOCATION,MAX and AVAILABLE\n");
   printf("2. Display ALLOCATION,MAX and NEED\n");
   printf("3. Display AVAILABLE\n");
   printf("4. EXIT\n");
   printf("Enter your choice....\n");
   scanf("%d",&choice);
   switch(choice)
   {
        case 1: get_data();
                break;
        case 2: display_alloc_need();
                break;
        case 3: display_avail();
                break;
        case 4: exit(0);
        
   }// end of switch
  }//end of while loop
} //end of main
///----------------------------------------------
void get_data()
{
  printf ("Enter no. of processes\n");
  scanf("%d",&n);

  printf ("Enter no. of resources\n");
  scanf ("%d",&m);
 //Accept ALLOCATION
 printf ("Enter ALLOCATION Matrix\n");
 for (i = 0; i < n; i++)
  for (j = 0; j < m; j++)
    scanf ("%d", &alloc[i][j]);

//Accept MAX
printf ("Enter MAX Matrix\n");
for (i = 0; i < n; i++)
  for (j = 0; j < m; j++)
    scanf ("%d",&max[i][j]);

//Accept AVAILABLE 
printf ("Enter AVAILABLE of size %d", m);
for (i = 0; i < m; i++)
  scanf ("%d",&avail[i]);
}// end of get_data function
//-----------------------------------------------------------------
void display_alloc_need()
{
printf ("Allocation\t\t   Max\t\tNeed(Max-Allocation)");
printf ("\n");
for (i = 0; i < n; i++)
  {
    for (j = 0; j < m; j++)
      printf ("%d ", alloc[i][j]);
    printf ("\t");
    for (j = 0; j < m; j++)
      printf ("%d ",max[i][j]);
    printf ("\t\t");
    for (j = 0; j < m; j++)
      {
	need[i][j] = max[i][j] - alloc[i][j];
	printf ("%d ", need[i][j]);
      }
    printf ("\n");
  }

} //end of display_alloc_need function
//-----------------------------------------------------------------
void display_avail()
{
int f[n], ans[n], ind = 0;
for (k = 0; k < n; k++)
  {
    f[k] = 0;
  }

printf ("\nAvail matrix\n");
int y = 0;
for (k = 0; k < 5; k++)
  {
    for (i = 0; i < n; i++)
      {
	if (f[i] == 0)
	  {
	    int flag = 0;
	    for (j = 0; j < m; j++)
	    {
		if (need[i][j] > avail[j])
		  {
		    flag = 1;
		    break;
		  }
	    }
	    if (flag == 0)
	      {
		    ans[ind++] = i;
		    for (y = 0; y < m; y++)
		    avail[y] += alloc[i][y];
		    f[i] = 1;
	      }
	  }
      }
  }

for (i = 0; i < m; i++)
  printf ("%d  ", avail[i]);
printf ("\n\nFollowing is the safe sequence\n");
for (i = 0; i < n - 1; i++)
  printf ("p%d->", ans[i]+1);
printf ("p%d", ans[n - 1]+1);
}
//end of display_avail function



Slip 10

/*ASSIGNMENT 1 Set B
Q.1. Write a program to illustrate the concept of orphan process ( Using fork() and
sleep())( Refer Program 5).*/
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
int main()
{
   int pid=fork();
   if(pid>0)
 {
     printf("in parent process\n");
     printf("PID: %d\n",getpid());
  }
   else if(pid==0)
  {
    sleep(10);
    printf("\nin child process");
    printf("\nPID: %d",getppid());
    printf("\nChild PID:%d",getpid());
  }
    return 0;
 }
//Note that pid is 0 in child process and negative if
//fork()fails


Q2

/*ASSIGNMENT-4-SET-B-Q.1
 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
i. Implement OPT

*/#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}



Slip 11

/*Assignment 1 Set A 
1.Create a child process using fork(), display parent and child 
process id. Child process will display the message “Hello World” and 
the parent process should display “Hi”. 
*/
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
void forkexample()
{
	// child process because return value zero
	if (fork() == 0)
	{
		printf("Hello World from Child!\n");
		printf("Child Process Id is : %d", getpid());
	}
	// parent process because return value non-zero.
	else if (fork() >0 )
	{
		printf("Hi from Parent!\n");
		printf("parent Process ID is %d",getpid())
	}		
}
int main()
{
	forkexample();
	return 0;
}


Q2

/* ASSIGNMENT 4 Set A
Q.1. Write the simulation program to implement demand paging and show the page scheduling and
total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1
i. Implement FIFO*/
#include<stdio.h>
int n=12,f;//n is length of reference string
int in[20]={0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1};//Reference String
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;

void getData()
{
	printf("\nEnter no of frames:");
	scanf("%d",&f);
}

void initialize()
{
	pgfaultcnt=0;
	for(i=0; i<f; i++)
		p[i]=9999;
}

int isHit(int data)
{
	hit=0;
	for(j=0; j<f; j++)
	{
		if(p[j]==data)
		{
			hit=1;
			break;
		}
	}
	return hit;
}

int getHitIndex(int data)
{
	int hitind;
	for(k=0; k<f; k++)
	{
		if(p[k]==data)
		{
			hitind=k;
			break;
		}
	}
	return hitind;
}

void dispPages()
{
	for (k=0; k<f; k++)
	{
		if(p[k]!=9999)
			printf(" %d",p[k]);
	}
}

void dispPgFaultCnt()
{
	printf("\nTotal no of page faults:%d",pgfaultcnt);
}

void fifo()
{
	initialize();
	for(i=0; i<n; i++)
	{
		printf("\nFor %d :",in[i]);
		
		if(isHit(in[i])==0)
		{
			for(k=0; k<f-1; k++)
			p[k]=p[k+1];

		p[k]=in[i];
		pgfaultcnt++;
		dispPages();
	}
	else
		printf("No page fault");
	}
	dispPgFaultCnt();
}


int main()
{
        getData();
        fifo();
}
 



Slip 12

/*ASSIGNMENT 1 Set B
Q.1. Write a program to illustrate the concept of orphan process ( Using fork() and
sleep())( Refer Program 5).*/
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
int main()
{
   int pid=fork();
   if(pid>0)
 {
     printf("in parent process\n");
     printf("PID: %d\n",getpid());
  }
   else if(pid==0)
  {
    sleep(10);
    printf("\nin child process");
    printf("\nPID: %d",getppid());
    printf("\nChild PID:%d",getpid());
  }
    return 0;
 }
//Note that pid is 0 in child process and negative if
//fork()fails


Q2

/*ASSIGNMENT-4-SET-B-Q.1
 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
i. Implement OPT

*/#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}



Slip 13

Q1
/* ASSIGNMENT 1 SET B 
Q. Write a program that demonstrates the use of nice() system call. After a child process is started using fork(), assign higher priority to the child using nice() system call.*/

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
void main()
{
int pid, retnice;
printf("press DEL to stop process \n");
pid=fork();
    for(;;)
    {
        if(pid == 0)
            {
            retnice = nice(-5);
            printf("child gets higher CPU priority %d \n", retnice);
            sleep(1);
            }
        else
            {
            retnice=nice(4);
            printf("Parent gets lower CPU priority %d \n", retnice);
            sleep(1);
            }
    }
}


Q2
//Bankers algorithm
#include<stdio.h>
int main()
{
  // p0,p1,p2,p3,p4 are the process names here
int n,m,i,j,l,k,a,b;
n=5;//Number of process
m=3;// Number of resources
int need[n][m];
//allocation matrix
int alloc[5][3]={{0,1,0},//p0
  {2,0,0},
   {3,0,2},
   {2,1,1},
   {0,0,2}};

// max matrix
int max[5][3] = {{7,5,3},
  
   {3,2,2},
   {9,0,2},
   {2,2,2},
   {4,3,3}};
printf("Allocation\t   Max\t\tNeed(Max-Allocation)");
printf("\n");
 for(a=0;a<n;a++)
{
   for(b=0;b<m;b++)
      printf("%d ",alloc[a][b]);
    printf("\t\t");
   for(b=0;b<m;b++)
      printf("%d ",max[a][b]);
    printf("\t\t");
   for(b=0;b<m;b++)
    {
      need[a][b] = max [a][b]-alloc[a][b];
      printf("%d ",need[a][b]);
    }
  printf("\n");
}  
   

int avail[3]=  {3,3,2};//available resources
 int f[n],ans[n],ind=0;
for(k=0;k<n;k++)
{
  f[k]=0;
}
printf("\nAvail matrix\n");
int y=0;
for(k=0;k<5;k++)
{
  for(i=0;i<n;i++)
{
   if(f[i]==0)
{
  int flag=0;
  for(j=0;j<m;j++)
{
  if (need[i][j]>avail[j])
{
    flag=1;
    break;
}
}
if(flag==0)
{
  ans[ind++]=i;
  for(y=0;y<m;y++)
  avail[y]+=alloc[i][y];
  f[i]=1;
}
}
}
}
for(i=0;i<m;i++)
  printf("%d  ",avail[i]);
printf("\n\nFollowing is the safe sequence\n");
for(i=0;i<n-1;i++)
  printf("p%d->",ans[i]);
printf("p%d",ans[n-1]);
return (0);
}
 




Slip 14


/*ASSIGNMENT 1 SET B Q.3
Write a program to find the execution time taken for execution of a given set of instructions (use clock() function)*/


#include <time.h>
#include <stdio.h>

int main () {
   clock_t start_t, end_t, total_t;
   int i;

   start_t = clock();
   printf("Starting of the program, start_t = %ld\n", start_t);
    
   printf("Going to scan a big loop, start_t = %ld\n", start_t);
   for(i=0; i< 10000000; i++) {
   }
   end_t = clock();
   printf("End of the big loop, end_t = %ld\n", end_t);
   
   total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;
   printf("Total time taken by CPU: %f\n", total_t  );
   printf("Exiting of the program...\n");

   return(0);
}



Q2


/* ASSIGNMENT 4 Set A
Q.1. Write the simulation program to implement demand paging and show the page scheduling and
total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1
i. Implement FIFO*/
#include<stdio.h>
int n=12,f;//n is length of reference string
int in[20]={0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1};//Reference String
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;

void getData()
{
	printf("\nEnter no of frames:");
	scanf("%d",&f);
}

void initialize()
{
	pgfaultcnt=0;
	for(i=0; i<f; i++)
		p[i]=9999;
}

int isHit(int data)
{
	hit=0;
	for(j=0; j<f; j++)
	{
		if(p[j]==data)
		{
			hit=1;
			break;
		}
	}
	return hit;
}

int getHitIndex(int data)
{
	int hitind;
	for(k=0; k<f; k++)
	{
		if(p[k]==data)
		{
			hitind=k;
			break;
		}
	}
	return hitind;
}

void dispPages()
{
	for (k=0; k<f; k++)
	{
		if(p[k]!=9999)
			printf(" %d",p[k]);
	}
}

void dispPgFaultCnt()
{
	printf("\nTotal no of page faults:%d",pgfaultcnt);
}

void fifo()
{
	initialize();
	for(i=0; i<n; i++)
	{
		printf("\nFor %d :",in[i]);
		
		if(isHit(in[i])==0)
		{
			for(k=0; k<f-1; k++)
			p[k]=p[k+1];

		p[k]=in[i];
		pgfaultcnt++;
		dispPages();
	}
	else
		printf("No page fault");
	}
	dispPgFaultCnt();
}


int main()
{
        getData();
        fifo();
}
 



Slip 15

Q1  /*ASSIGNMENT 1 SET A 
. Creating a child process without terminating the parent process Write a program to create a child process using fork().The parent should goto sleep state and child process should begin its execution. In the child process, use execl() to execute the “ls” command.*/

#include <unistd.h>
#include<stdio.h> 
int main(void) 
{
	int f;
	char *binaryPath = "/bin/ls";
  	char *arg1 = "-lh";
  	char *arg2 = "/home";
    	printf("Creating a child process with fork...\n");
	fork();
	sleep(5);
	printf("Parent process is Sleeping for 5 seconds \n");
	execl(binaryPath, binaryPath, arg1, arg2, NULL);
	printf("Sleep is now over \n");
 	return 0;
}


Q2

/*ASSIGNMENT 4 SET B Q.2
Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String :7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
i. Implement LRU*/

#include<stdio.h>
int n=14,nf;
int in[20]={7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
 
    }
 
    return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 
}
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
void lru()
{
    initialize();
 
    int least[50];
    for(i=0; i<n; i++)
    {
 
        printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
 
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i-1; k>=0; k--)
                {
                    if(pg==in[k])
                    {
                        least[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    least[j]=-9999;
            }
            int min=9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(least[j]<min)
                {
                    min=least[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault!");
    }
    dispPgFaultCnt();
}
 
void main()
{
            getData();
            lru();
}




Slip 16


/*ASSIGNMENT 1 SET B Q.3
Write a program to find the execution time taken for execution of a given set of instructions (use clock() function)*/


#include <time.h>
#include <stdio.h>

int main () {
   clock_t start_t, end_t, total_t;
   int i;

   start_t = clock();
   printf("Starting of the program, start_t = %ld\n", start_t);
    
   printf("Going to scan a big loop, start_t = %ld\n", start_t);
   for(i=0; i< 10000000; i++) {
   }
   end_t = clock();
   printf("End of the big loop, end_t = %ld\n", end_t);
   
   total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;
   printf("Total time taken by CPU: %f\n", total_t  );
   printf("Exiting of the program...\n");

   return(0);
}


Q2

/*ASSIGNMENT-4-SET-B-Q.1
 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
i. Implement OPT

*/#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}


Slip 17

/*SET A
1. Write the program to calculate minimum number of resources needed to avoid deadlock.
*/
/*Given: A system has R identical resources, P processes competing for them and N is the maximum need of each process. The task is to find the minimum number of Resources required So that deadlock will never occur. 
Formula: 
R >= P * (N - 1) + 1 
Example:
Input : P = 3, N = 4
Output : R >= 10

Input : P = 7, N = 2
Output : R >= 8 
*/

#include <stdio.h>

// function that calculates the minimum no. of resources
int Resources(int p, int n)
{
	int r = 0;

    r = p * (n - 1) + 1;//Condition so that deadlock will not    //occur

	return r;
}
// Driver code
int main()
{

    int process,need;
    printf("Enter the no of process and max need of every process\n");
    scanf("%d%d",&process,&need);

    printf("R >= %d",Resources(process, need));
    return 0;
}



Q2


/*ASSIGNMENT-4-SET-B-Q.1
 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
i. Implement OPT

*/#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}



Slip 18



/*Q2)2. Write a C program to accept the number of process and resources and find the need matrix content and display it. */

#include<stdio.h>
#include<stdlib.h>
int main()
{
int n,m,i,j,k,a,b;
int alloc[10][10],max[10][10],need[10][10],avail[10][10];
int work[10];  //available resources
int total_resources[10],temp[10];

printf("Enter no of processes: ");
scanf("%d",&n);

printf("Enter no of resources: ");
scanf("%d",&m);

for(i=0;i<m;i++)
{
   printf("Enter no. of instances of resource %d: \n",i+1);
   scanf("%d",&total_resources[i]);
}

printf("Enter allocation matrix\n");
for (i=0;i<n;i++) {
  for (j=0;j<m;j++) {
 	scanf("%d",&alloc[i][j]);
   }
}

printf("Enter MAX matrix\n");
for (i=0;i<n;i++) {
   for (j=0;j<m;j++) {
 	scanf("%d",&max[i][j]);
   }
}
printf("Enter Avail matrix\n");
for (i=0;i<n;i++) {
   for (j=0;j<m;j++) {
 	scanf("%d",&avail[i][j]);
}
}



printf("Allocation Matrix is .....\n");
for (i=0;i<n;i++)
{
   for (j=0;j<m;j++)
 	printf("%d  ",alloc[i][j]);
    printf("\n");
}

printf("Max Matrix is .....\n");
for (i=0;i<n;i++)
{
   for (j=0;j<m;j++)
 	printf("%d  ",max[i][j]);
    printf("\n");
}
for(i=0;i<n;i++)
{
	  for(j=0;j<m;j++)
	  {
		need[i][j]=max[i][j]-alloc[i][j];
	  }
	  printf("\n");
}
printf("Need Matrix is ....\n");
	for(i=0;i<n;i++)
	{
	  for(j=0;j<m;j++)
	  {
		printf("%d\t",need[i][j] );
	  }
	  printf("\n");
	}
}



Q2

/*ASSIGNMENT-4-SET-B-Q.1
 Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8
i. Implement OPT

*/#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}


Slip 19


Q1 /*ASSIGNMENT 1 SET A 
 Creating a child process without terminating the parent process Write a program to create a child process using fork().The parent should goto sleep state and child process should begin its execution. In the child process, use execl() to execute the “ls” command.*/

#include <unistd.h>
#include<stdio.h> 
int main(void) 
{
	int f;
	char *binaryPath = "/bin/ls";
  	char *arg1 = "-lh";
  	char *arg2 = "/home";
    	printf("Creating a child process with fork...\n");
	fork();
	sleep(5);
	printf("Parent process is Sleeping for 5 seconds \n");
	execl(binaryPath, binaryPath, arg1, arg2, NULL);
	printf("Sleep is now over \n");
 	return 0;
}



Q2


//Bankers algorithm
#include<stdio.h>
int main()
{
  // p0,p1,p2,p3,p4 are the process names here
int n,m,i,j,l,k,a,b;
n=5;//Number of process
m=3;// Number of resources
int need[n][m];
//allocation matrix
int alloc[5][3]={{0,1,0},//p0
  {2,0,0},
   {3,0,2},
   {2,1,1},
   {0,0,2}};

// max matrix
int max[5][3] = {{7,5,3},
  
   {3,2,2},
   {9,0,2},
   {2,2,2},
   {4,3,3}};
printf("Allocation\t   Max\t\tNeed(Max-Allocation)");
printf("\n");
 for(a=0;a<n;a++)
{
   for(b=0;b<m;b++)
      printf("%d ",alloc[a][b]);
    printf("\t\t");
   for(b=0;b<m;b++)
      printf("%d ",max[a][b]);
    printf("\t\t");
   for(b=0;b<m;b++)
    {
      need[a][b] = max [a][b]-alloc[a][b];
      printf("%d ",need[a][b]);
    }
  printf("\n");
}  
   

int avail[3]=  {3,3,2};//available resources
 int f[n],ans[n],ind=0;
for(k=0;k<n;k++)
{
  f[k]=0;
}
printf("\nAvail matrix\n");
int y=0;
for(k=0;k<5;k++)
{
  for(i=0;i<n;i++)
{
   if(f[i]==0)
{
  int flag=0;
  for(j=0;j<m;j++)
{
  if (need[i][j]>avail[j])
{
    flag=1;
    break;
}
}
if(flag==0)
{
  ans[ind++]=i;
  for(y=0;y<m;y++)
  avail[y]+=alloc[i][y];
  f[i]=1;
}
}
}
}
for(i=0;i<m;i++)
  printf("%d  ",avail[i]);
printf("\n\nFollowing is the safe sequence\n");
for(i=0;i<n-1;i++)
  printf("p%d->",ans[i]);
printf("p%d",ans[n-1]);
return (0);
}
 


SLip 20


Q1 /*ASSIGNMENT 1 SET A 
3. Creating a child process without terminating the parent process Write a program to create a child process using fork().The parent should goto sleep state and child process should begin its execution. In the child process, use execl() to execute the “ls” command.*/

#include <unistd.h>
#include<stdio.h> 
int main(void) 
{
	int f;
	char *binaryPath = "/bin/ls";
  	char *arg1 = "-lh";
  	char *arg2 = "/home";
    	printf("Creating a child process with fork...\n");
	fork();
	sleep(5);
	printf("Parent process is Sleeping for 5 seconds \n");
	execl(binaryPath, binaryPath, arg1, arg2, NULL);
	printf("Sleep is now over \n");
 	return 0;
}


Q2

/*ASSIGNMENT 4 SET B Q.2
Write the simulation program to implement demand paging and show the page scheduling and total number of page faults for the following given page reference string. Give input n as the number of memory frames.
Reference String :7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
i. Implement LRU*/

#include<stdio.h>
int n=14,nf;
int in[20]={7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
 
    }
 
    return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 
}
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
void lru()
{
    initialize();
 
    int least[50];
    for(i=0; i<n; i++)
    {
 
        printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
 
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i-1; k>=0; k--)
                {
                    if(pg==in[k])
                    {
                        least[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    least[j]=-9999;
            }
            int min=9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(least[j]<min)
                {
                    min=least[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault!");
    }
    dispPgFaultCnt();
}
 
void main()
{
            getData();
            lru();
}















9. Consider the following graph 


The numbers written on edges represent the distance between the nodes. The numbers written on nodes represent the heuristic value. 


Answer : 

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define N 10  // Number of nodes (A-J)
#define INF INT_MAX

// Graph edges and heuristic values (as seen in the image)
int graph[N][N] = {
    {0, 8, INF, 10, INF, 3, INF, INF, INF, INF}, // A
    {8, 0, 5, INF, 5, INF, INF, INF, INF, INF},  // B
    {INF, 5, 0, 3, INF, INF, INF, INF, INF, INF}, // C
    {10, INF, 3, 0, 3, INF, INF, INF, INF, INF}, // D
    {INF, 5, INF, 3, 0, INF, INF, 3, INF, INF},  // E
    {3, INF, INF, INF, INF, 0, 6, INF, INF, INF}, // F
    {INF, INF, INF, INF, INF, 6, 0, INF, 3, INF}, // G
    {INF, INF, INF, INF, 3, INF, INF, 0, 1, 2},  // H
    {INF, INF, INF, INF, INF, INF, 3, 1, 0, 3},  // I
    {INF, INF, INF, INF, INF, INF, INF, 2, 3, 0}  // J
};

// Heuristic values for nodes A to J
int heuristic[N] = {10, 8, 5, 7, 3, 6, 5, 3, 1, 0};

// Structure for a priority queue node
typedef struct {
    int node;
    int f_score;
} PQNode;

// Priority queue for the A* algorithm
typedef struct {
    PQNode *data;
    int size;
    int capacity;
} PriorityQueue;

PriorityQueue* createQueue(int capacity) {
    PriorityQueue *pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->data = (PQNode*)malloc(capacity * sizeof(PQNode));
    pq->size = 0;
    pq->capacity = capacity;
    return pq;
}

void enqueue(PriorityQueue *pq, int node, int f_score) {
    PQNode newNode = {node, f_score};
    pq->data[pq->size++] = newNode;
    int i = pq->size - 1;
    while (i > 0 && pq->data[i].f_score < pq->data[(i - 1) / 2].f_score) {
        PQNode temp = pq->data[i];
        pq->data[i] = pq->data[(i - 1) / 2];
        pq->data[(i - 1) / 2] = temp;
        i = (i - 1) / 2;
    }
}

int dequeue(PriorityQueue *pq) {
    if (pq->size == 0) return -1;
    int minNode = pq->data[0].node;
    pq->data[0] = pq->data[--pq->size];
    int i = 0;
    while (2 * i + 1 < pq->size) {
        int j = 2 * i + 1;
        if (j + 1 < pq->size && pq->data[j + 1].f_score < pq->data[j].f_score) j++;
        if (pq->data[i].f_score <= pq->data[j].f_score) break;
        PQNode temp = pq->data[i];
        pq->data[i] = pq->data[j];
        pq->data[j] = temp;
        i = j;
    }
    return minNode;
}

int a_star(int start, int goal) {
    int g_score[N];
    int f_score[N];
    int came_from[N];
    int visited[N] = {0};
    
    for (int i = 0; i < N; i++) {
        g_score[i] = INF;
        f_score[i] = INF;
        came_from[i] = -1;
    }
    g_score[start] = 0;
    f_score[start] = heuristic[start];
    
    PriorityQueue *pq = createQueue(N);
    enqueue(pq, start, f_score[start]);
    
    while (pq->size > 0) {
        int current = dequeue(pq);
        if (current == goal) {
            printf("Path: ");
            int node = goal;
            while (node != -1) {
                printf("%c ", 'A' + node);
                node = came_from[node];
            }
            printf("\nTotal Cost: %d\n", g_score[goal]);
            return g_score[goal];
        }
        
        visited[current] = 1;
        
        for (int neighbor = 0; neighbor < N; neighbor++) {
            if (graph[current][neighbor] != INF && !visited[neighbor]) {
                int tentative_g_score = g_score[current] + graph[current][neighbor];
                if (tentative_g_score < g_score[neighbor]) {
                    came_from[neighbor] = current;
                    g_score[neighbor] = tentative_g_score;
                    f_score[neighbor] = g_score[neighbor] + heuristic[neighbor];
                    enqueue(pq, neighbor, f_score[neighbor]);
                }
            }
        }
    }
    
    printf("Path not found!\n");
    return INF;
}

int main() {
    int start = 0; // Node A
    int goal = 9;  // Node J
    a_star(start, goal);
    return 0;
}








11. Implement AO* algorithm in C /python for following graph and find out minimum cost solution. 

Answer:

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define N 6 // Number of nodes (A-F)
#define INF INT_MAX

// Graph edges as adjacency matrix with costs
int graph[N][N] = {
    {INF, 4, 8, 5, INF, INF}, // A
    {INF, INF, 2, INF, INF, INF}, // B
    {INF, INF, INF, 2, 2, INF}, // C
    {INF, INF, INF, INF, INF, 8}, // D
    {INF, INF, INF, INF, INF, 4}, // E
    {INF, INF, INF, INF, INF, INF}  // F (goal node)
};

// Cost values for each node, initialized to INF
int cost[N];
int parent[N];

// AO* Algorithm Function
int AOStar(int node) {
    if (node == 5) {  // If node is the goal node F
        cost[node] = 0;
        return cost[node];
    }

    int minCost = INF;
    int selectedChild = -1;

    // Explore children nodes
    for (int child = 0; child < N; child++) {
        if (graph[node][child] != INF) {  // If there's an edge from node to child
            int childCost = graph[node][child] + AOStar(child);
            if (childCost < minCost) {
                minCost = childCost;
                selectedChild = child;
            }
        }
    }

    if (selectedChild != -1) {
        cost[node] = minCost;
        parent[node] = selectedChild;
    }

    return cost[node];
}

// Function to display the solution path
void displayPath(int start) {
    printf("Solution Path: ");
    int node = start;
    while (node != -1) {
        printf("%c ", 'A' + node);
        node = parent[node];
    }
    printf("\n");
}

int main() {
    // Initialize costs and parent array
    for (int i = 0; i < N; i++) {
        cost[i] = INF;
        parent[i] = -1;
    }

    // Start AO* from node A (index 0)
    int startNode = 0;
    int minCost = AOStar(startNode);

    printf("Minimum Cost: %d\n", minCost);
    displayPath(startNode);

    return 0;
}
















16. Given an initial state of a 8-puzzle problem and final state to be reached


 Find the most cost-effective path to reach the final state from initial state using A* Algorithm in C/Python.

Answer:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define N 3
#define INF 1000000

typedef struct Node {
    int state[N][N];
    int g, h;
    int blank_x, blank_y;
    struct Node* parent;
} Node;

int goal_state[N][N] = {
    {1, 2, 3},
    {8, 0, 4},
    {7, 6, 5}
};

// Moves: up, down, left, right
int moves[4][2] = {
    {-1, 0},  // up
    {1, 0},   // down
    {0, -1},  // left
    {0, 1}    // right
};

// Calculate Manhattan distance
int manhattan_distance(int state[N][N]) {
    int distance = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (state[i][j] != 0) {
                int target_x = (state[i][j] - 1) / N;
                int target_y = (state[i][j] - 1) % N;
                distance += abs(target_x - i) + abs(target_y - j);
            }
        }
    }
    return distance;
}

// Create a new node
Node* createNode(int state[N][N], int g, int h, int blank_x, int blank_y, Node* parent) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    memcpy(newNode->state, state, sizeof(newNode->state));
    newNode->g = g;
    newNode->h = h;
    newNode->blank_x = blank_x;
    newNode->blank_y = blank_y;
    newNode->parent = parent;
    return newNode;
}

// Check if the given state is the goal state
int is_goal(int state[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (state[i][j] != goal_state[i][j]) return 0;
        }
    }
    return 1;
}

// Print the puzzle state
void print_state(int state[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d ", state[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

// Print the solution path
void printSolution(Node* node) {
    if (node == NULL) return;
    printSolution(node->parent);
    print_state(node->state);
}

// A* Algorithm for solving 8-puzzle
void a_star(int initial_state[N][N], int blank_x, int blank_y) {
    Node* open_list[10000];
    int open_count = 0;
    int g, h;

    // Initial node
    g = 0;
    h = manhattan_distance(initial_state);
    Node* initial = createNode(initial_state, g, h, blank_x, blank_y, NULL);
    open_list[open_count++] = initial;

    while (open_count > 0) {
        // Find the node with the lowest f = g + h
        int min_f = INF;
        int min_index = -1;
        for (int i = 0; i < open_count; i++) {
            int f = open_list[i]->g + open_list[i]->h;
            if (f < min_f) {
                min_f = f;
                min_index = i;
            }
        }

        // Pop the node with the lowest f
        Node* current = open_list[min_index];
        open_list[min_index] = open_list[--open_count];

        // If we reached the goal
        if (is_goal(current->state)) {
            printf("Reached the goal!\n");
            printSolution(current);
            return;
        }

        // Explore all possible moves
        for (int i = 0; i < 4; i++) {
            int new_x = current->blank_x + moves[i][0];
            int new_y = current->blank_y + moves[i][1];

            // Check if the move is within bounds
            if (new_x >= 0 && new_x < N && new_y >= 0 && new_y < N) {
                // Create a new state by swapping the blank tile
                int new_state[N][N];
                memcpy(new_state, current->state, sizeof(new_state));
                new_state[current->blank_x][current->blank_y] = new_state[new_x][new_y];
                new_state[new_x][new_y] = 0;

                // Calculate g(n) and h(n) for the new state
                g = current->g + 1;
                h = manhattan_distance(new_state);
                Node* child = createNode(new_state, g, h, new_x, new_y, current);

                // Add the new state to the open list
                open_list[open_count++] = child;
            }
        }
    }

    printf("No solution found.\n");
}

// Main function
int main() {
    // Initial state of the puzzle
    int initial_state[N][N] = {
        {2, 8, 3},
        {1, 6, 4},
        {7, 0, 5}
    };

    // Position of the blank tile (0)
    int blank_x = 2, blank_y = 1;

    // Run A* to solve the puzzle
    a_star(initial_state, blank_x, blank_y);

    return 0;
}
